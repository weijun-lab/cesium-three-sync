(function(o,n){typeof exports=="object"&&typeof module!="undefined"?module.exports=n(require("three")):typeof define=="function"&&define.amd?define(["three"],n):(o=typeof globalThis!="undefined"?globalThis:o||self,o.CesiumThreeSync=n(o.THREE))})(this,function(o){"use strict";function n(s){const i=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(s){for(const e in s)if(e!=="default"){const t=Object.getOwnPropertyDescriptor(s,e);Object.defineProperty(i,e,t.get?t:{enumerable:!0,get:()=>s[e]})}}return i.default=s,Object.freeze(i)}const a=n(o);class m{constructor(i){this.cesiumViewer=i}attachRendererDomToCesium(i){let e=this.cesiumViewer.container;i.setSize(e.offsetWidth,e.offsetHeight),i.domElement.style.position="absolute",i.domElement.style.top="0",i.domElement.style.width="100%",i.domElement.style.height="100%",i.domElement.style.pointerEvents="none",e.appendChild(i.domElement)}syncCamera(i){i.matrixAutoUpdate=!1,i.fov=Cesium.Math.toDegrees(this.cesiumViewer.camera.frustum.fovy);let e=this.cesiumViewer.camera.viewMatrix,t=this.cesiumViewer.camera.inverseViewMatrix;i.matrixWorld.set(t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15]),i.matrixWorldInverse.set(e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15]);let r=this.cesiumViewer.container,u=r.offsetWidth,c=r.offsetHeight,l=u/c;i.aspect=l,i.updateProjectionMatrix()}createBridgeContainer(i){let e=Cesium.Transforms.eastNorthUpToFixedFrame(i),t=new a.Matrix4;t.set(e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],0,0,0,1),t.multiply(new a.Matrix4().makeRotationX(Math.PI/2));let r=new a.Group;return r.applyMatrix4(t),r}}return m});
